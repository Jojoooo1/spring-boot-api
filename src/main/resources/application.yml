miscellaneous:
  max-response-time-to-log-in-ms: ${MAX_RESPONSE_TIME_TO_LOG_IN_MS:1000}

http:
  clients:
    default-timeout: ${HTTP_CLIENTS_DEFAULT_TIMEOUT:5000}
    my-external-api:
      base-url: ${HTTP_CLIENTS_MY_EXTERNAL_API_BASE_URL}

rate-limit:
  default:
    name: ${DEFAULT_RATE_LIMIT_NAME:DEFAULT}
    max-requests: ${DEFAULT_MAX_REQUESTS:50}
    refill-in-seconds: ${DEFAULT_REFILL_IN_SECONDS:1}

slack:
  username: ${SLACK_USERNAME}
  channels:
    api-alert:
      url: ${SLACK_API_ALERT_URL}
      name: ${SLACK_API_ALERT_CHANNEL}

rabbitmq:
  host: ${RABBITMQ_HOST}
  port: ${RABBITMQ_PORT}
  username: ${RABBITMQ_USERNAME}
  password: ${RABBITMQ_PASSWORD}
  listeners:
    event:
      queue: ${RABBITMQ_LISTENERS_EVENT_QUEUE}
      prefetch-count: ${RABBITMQ_LISTENERS_EVENT_PREFETCH_COUNT:10}
  publishers:
    webhook:
      exchange: ${RABBITMQ_PUBLISHERS_WEBHOOK_EXCHANGE}
      routingkey: ${RABBITMQ_PUBLISHERS_WEBHOOK_ROUTING_KEY}

kubernetes:
  service-name: ${KUBERNETES_SERVICE_NAME:api}

management:
  server:
    port: 8081 # change this in production
  endpoints:
    web:
      exposure:
        include: info, health, prometheus, metrics, preStopHook
  tracing:
    sampling:
      probability: 0
  #  otlp:
  #    tracing:
  #      endpoint:
  endpoint:
    health:
      probes:
        enabled: true
        add-additional-paths: true
    #      group:
    #       readiness:
    #         include: rabbit
    metrics:
      distribution:
        percentiles-histogram:
          http:
            server:
              requests: true
  info:
    java:
      enabled: true

spring:
  application:
    name: api
  threads:
    virtual:
      enabled: true
  web:
    resources:
      add-mappings: false # disable serving of static content entirely.
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${SECURITY_OAUTH_ISSUER_URI}
          jwk-set-uri: ${SECURITY_OAUTH_JWK_SET_URI}
  data:
    web:
      pageable:
        max-page-size: 20 # default 2000

  flyway:
    locations: classpath:/db/migration/postgresql

  datasource:
    hikari.maximum-pool-size: ${DB_MAX_POOL_SIZE:20}
    url: jdbc:postgresql://${DB_HOST}/${DB_NAME}?stringtype=unspecified&reWriteBatchedInserts=true
    username: ${DB_USER}
    password: ${DB_PASSWORD}

  jpa:
    open-in-view: false # disable lazy loading in web views, important for performance.
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        generate_statistics: false
        jdbc:
          # Important: When using GenerationType.IDENTITY Hibernate disable batching, you need to use BatchSequenceGenerator
          batch_size: ${JDBC_BATCH_SIZE:10}
          time_zone: ${JDBC_TIMEZONE:America/Sao_Paulo}

    #  jackson:
    #    property-naming-strategy: LOWER_CAMEL_CASE
    #  visibility.field: any
    #  visibility.getter: none
    #  visibility.setter: none
    #  visibility.is-getter: none

    serialization:
      write-dates-as-timestamps: false
      fail-on-empty-beans: false

  rabbitmq:
    template:
      retry:
        enabled: true

  lifecycle:
    timeout-per-shutdown-phase: 20s

server:
  shutdown: graceful
  tomcat:
    # enable tomcat metrics
    mbeanregistry:
      enabled: true

---
spring:
  config:
    activate:
      on-profile: replication
  flyway:
    locations: classpath:/db/migration/replication,classpath:/db/migration/postgresql